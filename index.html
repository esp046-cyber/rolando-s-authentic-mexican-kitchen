<change>
<file>index.html</file>
<description>Final clean index.html - removed all invalid code and text artifacts</description>
<content><![CDATA[<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" />
<title>Rolando's Authentic Mexican Kitchen</title>
<meta name="description" content="Chef Rolando's curated collection of 200 authentic Mexican recipes." />
<meta name="theme-color" content="#f59e0b" />
<link rel="manifest" href="./manifest.json" />
code
Code
<style>
  /* Hide scrollbar for clean UI */
  .no-scrollbar::-webkit-scrollbar { display: none; }
  .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
  body { -webkit-tap-highlight-color: transparent; }
  
  /* Smooth Image Loading */
  img { transition: opacity 0.3s ease-in-out; }
</style>
</head>
<body class="bg-rolando-bg text-stone-800 antialiased select-none">
<div id="root"></div>
code
Code
<!-- MAIN ENTRY POINT: Vite will replace this with the built JavaScript -->
<script type="module" src="./index.tsx"></script>

<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      // Use relative path for Service Worker
      navigator.serviceWorker.register('./sw.js')
        .then(reg => {
          reg.update();
          console.log('SW registered');
        })
        .catch(err => console.log('SW registration failed', err));
    });
  }
</script>
</body>
</html>]]></content>
</change>
sw.js
<change>
<file>sw.js</file>
<description>Bump cache version to v51 to force fresh load</description>
<content><![CDATA[const CACHE_NAME = 'rolando-kitchen-v51';
// Use relative paths for GitHub Pages support
const urlsToCache = [
'./',
'./index.html',
'./manifest.json'
];
self.addEventListener('install', event => {
event.waitUntil(
caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache))
);
self.skipWaiting();
});
self.addEventListener('activate', event => {
event.waitUntil(
caches.keys().then(cacheNames => {
return Promise.all(
cacheNames.filter(name => name !== CACHE_NAME)
.map(name => caches.delete(name))
);
})
);
self.clients.claim();
});
self.addEventListener('fetch', event => {
const requestUrl = new URL(event.request.url);
// Pollinations.ai Image Caching (Cache First, Network Fallback)
if (requestUrl.hostname === 'image.pollinations.ai') {
event.respondWith(
caches.open(CACHE_NAME).then(cache => {
return cache.match(event.request).then(response => {
if (response) return response;
return fetch(event.request).then(networkResponse => {
if(networkResponse.ok) {
cache.put(event.request, networkResponse.clone());
}
return networkResponse;
});
});
})
);
return;
}
// Unsplash Image Caching (Cache First for static fallbacks)
if (requestUrl.hostname === 'images.unsplash.com') {
event.respondWith(
caches.open(CACHE_NAME).then(cache => {
return cache.match(event.request).then(response => {
if (response) return response;
return fetch(event.request).then(networkResponse => {
if(networkResponse.ok) {
cache.put(event.request, networkResponse.clone());
}
return networkResponse;
});
});
})
);
return;
}
// App Shell (Stale-While-Revalidate)
event.respondWith(
caches.match(event.request).then(response => {
const fetchPromise = fetch(event.request).then(networkResponse => {
caches.open(CACHE_NAME).then(cache => {
if(event.request.method === 'GET' && networkResponse.ok) {
cache.put(event.request, networkResponse.clone());
}
});
return networkResponse;
});
return response || fetchPromise;
})
);
});]]></content>
</change>
